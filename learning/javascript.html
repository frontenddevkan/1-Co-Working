<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JavaScript</title>
    <link rel="stylesheet" href="../css/main.css">
</head>
<body>
    <header>
        <div class="wrapper">
            <h1>JavaScript</h1>
            <img src="images/logo.png" alt="logo">
            <nav>
                <ul>
                    <li><a href="./index.html">На Главную</a></li>
                    <li><a href="./learning.html">Learning</a></li>
                    <li><a href="#">About</a></li>
                    <li><a href="#">Contact</a></li>
                    <li><a href="#">More</a></li>
                </ul>
            </nav>
        </div>

    </header>

    <main>
        <div class="wrapper">
            <nav class="parts">
                <ul>

                    <li>
                        <a href="#type-data" target="_blank">
                            Типы данных
                        </a>
                    </li>
                    <li>
                        <a href="#typeof" target="_blank">
                            Типы данных
                        </a>
                    </li>
                </ul>
            </nav>
        </div>


                    <h2 class="type-data" id="type-data">В JavaScript есть 8 основных типов данных.</h2>


<h3>Семь из них называют «примитивными» типами данных:</h3>

<ul>
    <li>number для любых чисел: целочисленных или чисел с плавающей точкой; целочисленные значения ограничены диапазоном ±(253-1).</li>
    <li>bigint для целых чисел произвольной длины.</li>
    <li>string для строк. Строка может содержать ноль или больше символов, нет отдельного символьного типа.</li>
    <li>boolean для true/false.</li>
    <li>null для неизвестных значений – отдельный тип, имеющий одно значение null.</li>
    <li>undefined для неприсвоенных значений – отдельный тип, имеющий одно значение undefined.</li>
    <li>symbol для уникальных идентификаторов.</li>
    <li>И один не является «примитивным» и стоит особняком: object для более сложных структур данных.</li>

    <h2> Операторы </h2>
    <ul>
        <li>Арифметические - Простые * + - /, а также деление по модулю % и возведение в степень **.</li>
        <li>Логические - Логические И &&, ИЛИ || используют так называемое «ленивое вычисление» и возвращают значение, на котором оно остановилось (не обязательно true или false). Логическое НЕ ! конвертирует операнд в логический тип и возвращает инвертированное значение.</li>

        <li>Унарные</li>
        <li>Операторы присваивания
            <ul>
                <li>Простые a = b </li>
                <li>и составные a *= 2</li>
            </ul>
        </li>
        <li>Битовые операции</li>
        <li>Условные - cond ? resultA : resultB. Если условие cond истинно, возвращается resultA, иначе – resultB.</li>
        <li>Оператор нулевого слияния -
            Оператор ?? предоставляет способ выбора определённого значения из списка переменных. Результатом a ?? b будет a, если только оно не равно null/undefined, тогда b.</li>
        <li>Сравнение -
            Проверка на равенство == значений разных типов конвертирует их в число (за исключением null и undefined, которые могут равняться только друг другу), так что примеры ниже равны</li>




    </ul>

<h3> унарный оператор + или Number(), пример с унарным оператором: +num.toFixed(5).</h3>

<h3 class="type-data" id="typeof">Оператор typeof позволяет нам увидеть, какой тип данных сохранён в переменной.</h3>

    <li>Имеет две формы: typeof x или typeof(x).</li>
Возвращает строку с именем типа. Например, "string".
Для null возвращается "object" – это ошибка в языке, на самом деле это не объект.

Оператор typeof возвращает тип аргумента. Это полезно, когда мы хотим обрабатывать значения различных типов по-разному или просто хотим сделать проверку.

У него есть две синтаксические формы:

// Обычный синтаксис
typeof 5 // Выведет "number"
// Синтаксис, напоминающий вызов функции (встречается реже)
typeof(5) // Также выведет "number"
Если передается выражение, то нужно заключать его в скобки, т.к. typeof имеет более высокий приоритет, чем бинарные операторы:

typeof 50 + " Квартир"; // Выведет "number Квартир"
typeof (50 + " Квартир"); // Выведет "string"
Другими словами, скобки необходимы для определения типа значения, которое получилось в результате выполнения выражения в них.

Вызов typeof x возвращает строку с именем типа:

typeof undefined // "undefined"

typeof 0 // "number"

typeof 10n // "bigint"

typeof true // "boolean"

typeof "foo" // "string"

typeof Symbol("id") // "symbol"

typeof Math // "object"  (1)

typeof null // "object"  (2)

typeof alert // "function"  (3)
Последние три строки нуждаются в пояснении:

Math — это встроенный объект, который предоставляет математические операции и константы. Мы рассмотрим его подробнее в главе Числа. Здесь он служит лишь примером объекта.
Результатом вызова typeof null является "object". Это официально признанная ошибка в typeof, ведущая начало с времён создания JavaScript и сохранённая для совместимости. Конечно, null не является объектом. Это специальное значение с отдельным типом.
Вызов typeof alert возвращает "function", потому что alert является функцией. Мы изучим функции в следующих главах, где заодно увидим, что в JavaScript нет специального типа «функция». Функции относятся к объектному типу. Но typeof обрабатывает их особым образом, возвращая "function". Так тоже повелось от создания JavaScript. Формально это неверно, но может быть удобным на практике.

<h2>Числа</h2>
<h4>В современном JavaScript существует два типа чисел:</h4>
<ol>
    <li>Обычные числа в JavaScript хранятся в 64-битном формате IEEE-754</li>
    <li>BigInt числа дают возможность работать с целыми числами произвольной длины. Они нужны достаточно редко и используются в случаях, когда необходимо работать со значениями более чем (253-1) или менее чем -(253-1)</li>
</ol>

<p>Шестнадцатеричные числа широко используются в JavaScript для представления цветов, кодировки символов и многого другого. </p>
<p></p>

<h3>Метод toString(base)</h3>
<p>Метод num.toString(base) возвращает строковое представление числа num в системе счисления base.</p>
<ul>
    <p>base может варьироваться от 2 до 36 (по умолчанию 10).</p>
    <li>base=16 — для шестнадцатеричного представления цвета, кодировки символов и т.д., цифры могут быть 0..9 или A..F</li>
    <li>base=2 — обычно используется для отладки побитовых операций, цифры 0 или 1</li>
    <li>base=10 — для целых чисел</li>
    <li>base=36 — максимальное основание, цифры могут быть 0..9 или A..Z. То есть, используется весь латинский алфавит для представления числа.</li>
</ul>

<h3>Округление</h3>
<ul>
    <li>Math.floor
        Округление в меньшую сторону: 3.1 становится 3, а -1.1 — -2.</li>
    <li>Math.ceil
        Округление в большую сторону: 3.1 становится 4, а -1.1 — -1.</li>
    <li>Math.round
        Округление до ближайшего целого: 3.1 становится 3, 3.6 — 4, а -1.1 — -1.</li>
    <li>Math.trunc (не поддерживается в Internet Explorer)
        Производит удаление дробной части без округления: 3.1 становится 3, а -1.1 — -1.</li>
    <li>Метод toFixed(n) округляет число до n знаков после запятой и возвращает строковое представление результата.</li>

</ul>
В JavaScript встроен объект Math, который содержит различные математические функции и константы.

Math.random()
Возвращает псевдослучайное число в диапазоне от 0 (включительно) до 1 (но не включая 1)

Math.max(a, b, c...) / Math.min(a, b, c...)
Возвращает наибольшее/наименьшее число из перечисленных аргументов.

Math.pow(n, power)
Возвращает число n, возведённое в степень power

Для проверки на NaN и Infinity:

isNaN(value) преобразует аргумент в число и проверяет, является ли оно NaN
Number.isNaN(value) проверяет, является ли аргумент числом, и если да, то проверяет, является ли оно NaN
isFinite(value) преобразует аргумент в число и проверяет, что оно не является NaN/Infinity/-Infinity
Number.isFinite(value) проверяет, является ли аргумент числом, и если да, то проверяет, что оно не является NaN/Infinity/-Infinity

Для преобразования значений типа 12pt и 100px в число:

Используйте parseInt/parseFloat для «мягкого» преобразования строки в число, данные функции по порядку считывают число из строки до тех пор пока не возникнет ошибка.
Для дробей:

Используйте округления Math.floor, Math.ceil, Math.trunc, Math.round или num.toFixed(precision).
Помните, что при работе с дробями происходит потеря точности.



<h2> функции для проверки чисел </h2>

<ul>
    <li>isNaN(value) преобразует значение в число и проверяет является ли оно NaN</li>
    <li>isFinite(value) преобразует аргумент в число и возвращает true, если оно является обычным числом, т.е. не NaN/Infinity/-Infinity:</li>
    <li>Существует специальный метод Object.is, который сравнивает значения примерно как ===, но более надёжен в двух особых ситуациях:
        Этот способ сравнения часто используется в спецификации JavaScript. Когда внутреннему алгоритму необходимо сравнить 2 значения на предмет точного совпадения, он использует Object.is
    </li>
    <li>«читают» число из строки. Если в процессе чтения возникает ошибка, они возвращают полученное до ошибки число. Функция parseInt возвращает целое число, а parseFloat возвращает число с плавающей точкой:</li>
    WeakMap – принципиально другая структура в этом аспекте. Она не предотвращает удаление объектов сборщиком мусора, когда эти объекты выступают в качестве ключей.

    Давайте посмотрим, что это означает, на примерах.

    WeakMap
    Первое его отличие от Map в том, что ключи в WeakMap должны быть объектами, а не примитивными значениями:

    WeakMap не поддерживает перебор и методы keys(), values(), entries(), так что нет способа взять все ключи или значения из неё.

    В WeakMap присутствуют только следующие методы:

    weakMap.get(key)
    weakMap.set(key, value)
    weakMap.delete(key)
    weakMap.has(key)

    WeakMap используется в качестве дополнительного хранилища данных.

    WeakSet
    Коллекция WeakSet ведёт себя похоже:

    Она аналогична Set, но мы можем добавлять в WeakSet только объекты (не примитивные значения).
    Объект присутствует в множестве только до тех пор, пока доступен где-то ещё.
    Как и Set, она поддерживает add, has и delete, но не size, keys() и не является перебираемой.
    Spread syntax позволяет расширить доступные для итерации элементы (например, массивы или строки) в местах



</ul>
</main>
<footer>

</footer>
</body>
</html>